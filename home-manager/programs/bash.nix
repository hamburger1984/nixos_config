{ pkgs, ...}:

{
  programs.bash = {
    enable = true;
    initExtra = ''
      #----- stolen from: https://github.com/mrzool/bash-sensible -----#
      ## GENERAL OPTIONS ##

      # Prevent file overwrite on stdout redirection
      # Use `>|` to force redirection to an existing file
      set -o noclobber

      # Update window size after every command
      shopt -s checkwinsize

      # Automatically trim long paths in the prompt (requires Bash 4.x)
      PROMPT_DIRTRIM=2

      # Enable history expansion with space
      # E.g. typing !!<space> will replace the !! with your last command
      bind Space:magic-space

      # Turn on recursive globbing (enables ** to recurse all directories)
      shopt -s globstar 2> /dev/null

      # Case-insensitive globbing (used in pathname expansion)
      shopt -s nocaseglob;

      ## SMARTER TAB-COMPLETION (Readline bindings) ##

      # Perform file completion in a case insensitive fashion
      bind "set completion-ignore-case on"

      # Treat hyphens and underscores as equivalent
      bind "set completion-map-case on"

      # Display matches for ambiguous patterns at first tab press
      bind "set show-all-if-ambiguous on"

      # Immediately add a trailing slash when autocompleting symlinks to directories
      bind "set mark-symlinked-directories on"

      ## SANE HISTORY DEFAULTS ##

      # Append to the history file, don't overwrite it
      shopt -s histappend

      # Save multi-line commands as one command
      shopt -s cmdhist

      # Record each line as it gets issued
      PROMPT_COMMAND='history -a'

      # Huge history. Doesn't appear to slow things down, so why not?
      HISTSIZE=500000
      HISTFILESIZE=100000

      # Avoid duplicate entries
      HISTCONTROL="erasedups:ignoreboth"

      # Don't record some commands
      export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear"

      # Use standard ISO 8601 timestamp
      # %F equivalent to %Y-%m-%d
      # %T equivalent to %H:%M:%S (24-hours format)
      HISTTIMEFORMAT='%F %T '

      # Enable incremental history search with up/down arrows (also Readline goodness)
      # Learn more about this here: http://codeinthehole.com/writing/the-most-important-command-line-tip-incremental-history-searching-with-inputrc/
      bind '"\e[A": history-search-backward'
      bind '"\e[B": history-search-forward'
      bind '"\e[C": forward-char'
      bind '"\e[D": backward-char'

      ## BETTER DIRECTORY NAVIGATION ##

      # Prepend cd to directory names automatically
      shopt -s autocd 2> /dev/null
      # Correct spelling errors during tab-completion
      shopt -s dirspell 2> /dev/null
      # Correct spelling errors in arguments supplied to cd
      shopt -s cdspell 2> /dev/null

      # This defines where cd looks for targets
      # Add the directories you want to have fast access to, separated by colon
      # Ex: CDPATH=".:~:~/projects" will look for targets in the current working directory, in home and in the ~/projects folder
      CDPATH="."

      # This allows you to bookmark your favorite places across the file system
      # Define a variable containing a path and you will be able to cd into it regardless of the directory you're in
      shopt -s cdable_vars

      # Examples:
      # export dotfiles="$HOME/dotfiles"
      # export projects="$HOME/projects"
      # export documents="$HOME/Documents"
      # export dropbox="$HOME/Dropbox"
      #----- stolen from: https://github.com/mrzool/bash-sensible -----#

      # Workaround for nix-shell --pure
      if [ "$IN_NIX_SHELL" == "pure" ]; then
        if [ -x "$HOME/.nix-profile/bin/powerline-go" ]; then
          alias powerline-go="$HOME/.nix-profile/bin/powerline-go"
        elif [ -x "/run/current-system/sw/bin/powerline-go" ]; then
          alias powerline-go="/run/current-system/sw/bin/powerline-go"
        fi
      fi

      function _update_ps1() {
        PS1="$(powerline-go -error $? -hostname-only-if-ssh -modules time,venv,user,host,ssh,cwd,perms,git,hg,jobs,exit,root -jobs $(jobs -p | wc -l))"
      }

      if [ "$TERM" != "linux" ] && [ -x "$(command -v powerline-go)" ]; then
        PROMPT_COMMAND="_update_ps1; $PROMPT_COMMAND"
      fi

      export PATH="$PATH:/home/andreas/.dotnet/tools:/home/andreas/.local/bin"

      alias ls="exa --icons"
      alias l="exa -l --icons"
      alias ll="exa -la --icons"
      alias latest="exa -l -s created --icons"

      # git
      alias rpull='find . -type d -name .git -exec sh -c "cd \"{}\"/../ && echo -n \"----- \" && echo \"{}\" | rev | cut -d\"/\" -f2 | rev && git pull" \;'
      alias rfetch='find . -type d -name .git -exec sh -c "cd \"{}\"/../ && echo -n \"----- \" && echo \"{}\" | rev | cut -d\"/\" -f2 | rev && git fetch --all --prune" \;'

      eval "$(zoxide init bash)"

      # This script was automatically generated by the broot program
      # More information can be found in https://github.com/Canop/broot
      # This function starts broot and executes the command
      # it produces, if any.
      # It's needed because some shell commands, like `cd`,
      # have no useful effect if executed in a subshell.
      function br {
          local cmd cmd_file code
          cmd_file=$(mktemp)
          if broot --outcmd "$cmd_file" "$@"; then
              cmd=$(<"$cmd_file")
              rm -f "$cmd_file"
              eval "$cmd"
          else
              code=$?
              rm -f "$cmd_file"
              return "$code"
          fi
      }
    '';
  };
}
